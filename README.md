# Burrows-Wheeler Compression

This is an attempt -in C- at the Burrows Wheeler compression algorithm that utilizes LSD-radix sort and MSD-radix sort as its suffix sorting algorithms. The main idea is to refrain from using any sorting libraries or the string library itself, and to make exclusive use of pointers and array indexing to implement both sorting algorithms. In terms of memory space, radix sort might be more wasteful than other methods in its reliance on count sort, but it was easier to implement and to plan out conceptually as the implementation I had in mind made exclusive use of a suffix array. This in turn introduced some trivial calculations, but they are also frequent; optimizing these calculations could be worth doing in the future. The program takes a path to a regular text file as input, and outputs the transformed array, and its associated ordered suffixes after applying both methods.

## LSD-Radix Sort:

The least significant digit (LSD) radix sort works by sorting suffixes based on the current least signficiant digit. At every round, a new suffix is introduced and is given a new key value. Sorting is performed on a column of characters of in old suffixes shifted by one position to the left, in addition to the right-most  character of a newly added suffix (which is always the last character of the text itself).For example, during the second round of sorting the second suffix in BANANA (which is ANANA) is given the key-value of 2. During the third round, the correct character column should be at the first 'N' from the right in ANANA aligned to the second 'A' in BANANA, and the first 'A' in NANA (which is given a key value of 3).

As it stands, any text will work as long as it is terminated with a unique character that is not found in anywhere else in the text. This character could be of any value ('$' works for example but so does any unique character). This is most likely due to the fact that radix sort is **stable**, as it relies on count sort on columns of characters from least to most significant digit; the last character in a text is also the absolute last suffix to be added, and smallest to be sorted (a single character), so it will always appear at the end of a grouping of occurrences of that character in any of the previous suffixes, rather than in the first position within that grouping where it should be.

## MSD-Radix Sort:

This is an implementation of the most significant digit (MSD) string sort algorithm adapted from Segwwick's & Wayne's "Algorithms"; a recursive radix sort based on the most significant digit. The algorithm first sorts all suffixes based on the most significant digit, then acts recursively on the next significant digit in subsets of suffixes sharing an identical **previous** significant digit. As the book states, MSD-Radix Sort has a worst case running time linear to the total number of characters, same as the other version of radix sort, it is however significantly more wasteful in terms of space; every run could potentially require the construction of (n -1)! arrays of size equal to the alphabet of the text (256 for ASCII), which could also have a devastating efffect on running time brought on by frequent memory accesses. This is mitigated greatly by replacing count sort with insertion sort for small subarrays. 

The code so far does not have an implementation of insertion sort in place, but it does produces the **correct** overall result. Unlike the canonical radix sort implemented here, MSD-radix sort does not require a unique terminating character. It works on any string and on any collection of arbitrary suffixes. 

## Parallelism//Not Good

In theory, the recursion part in MSD-radix sort can be made explicitly concurrent as sorting subarrays (within a current character postion but **not** subsequent ones) is data independent. However, there are two issues that become immediately apprent for a direct impementation of threading on top of radix sort.

1.	Space: counting sort relies on a couple of auxiliary arrays for keeping count, and for generating new upper indices for subsequent subarrays in the recursion. For ASCII characters, each is 256 integers long, for unicode it is in the upper range of tens of thousands. An alternative would to be to do away with count sort completely and replace it with a stable, in-place sorting algorithm, or to limit the number of concurrent threads while keeping recursion in mind, somehowever.

2.	Race conditions: a partial parallel version of count is sort is possible, specifically the counting phase. This naturally exacerbates the issue with space, as multiple auxiliary arrays would have to be maintained, unless a static counting array is shared among all theads. This in turn leads to a race condition between reading a particular count from memory, incrementing that count by one and writing it back to memory. A mutex could eliminate that issue, but it further adds to the overall running time as they are (to my knowledge)expensive. It might be worth it if the cost is significantly amortized however.
