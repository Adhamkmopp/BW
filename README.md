# Burrows-Wheeler Compression

This is an attempt -in C- at the Burrows Wheeler compression algorithm that utilizes LSD-radix sort and MSD-radix sort as its suffix sorting algorithms. The main idea is to refrain from using any sorting libraries or the string library itself, and to make exclusive use of pointers and array indexing to implement both sorting algorithms. In terms of memory space, it might be more wasteful than other methods in its reliance on count sort, but it was easier to implement and to plan out conceptually as the implementation I had in mind made exclusive use of a single moving pointer to reference different suffixes. This in turn introduced some trivial calculations, but they are also frequent; optimizing these calculations could be worth doing in the future. The program takes a path to a regular text file as input, and outputs the transformed array, and its associated ordered suffixes after applying both methods.

## LSD-Radix Sort:

The least significant digit (LSD) radix sort works by sorting suffixes based on the current least signficiant digit. At every round, a new suffix is introduced and is given a new key value. Sorting is performed on a column of characters of in old suffixes shifted by one position to the left, in addition to the right-most  character of a newly added suffix (which is always the last character of the text itself).For example, during the second round of sorting the second suffix in BANANA (which is ANANA) is given the key-value of 2. During the third round, the correct character column should be at the first 'N' from the right in ANANA aligned to the second 'A' in BANANA, and the first 'A' in NANA (which is given a key value of 3).

As it stands, any text will work as long as it is terminated with a unique character that is not found in anywhere else in the text. This character could be of any value ('$' works for example but so does any unique character). This is most likely due to the fact that radix sort is **stable**, as it relies on count sort on columns of characters from least to most significant digit; the last character in a text is also the absolute last suffix to be added, and smallest to be sorted (a single character), so it will always appear at the end of a grouping of occurrences of that character in any of the previous suffixes, rather than in the first position within that grouping where it should be.

## MSD-Radix Sort:

This is an implementation of the most significant digit (MSD) string sort algorithm adapted from Segwwick's & Wayne's "Algorithms"; a recursive radix sort based on the most significant digit. The algorithm first sorts all suffixes based on the most significant digit, then acts recursively on the next significant digit in subsets of suffixes sharing an identical **previous** significant digit. As the book states, MSD-Radix Sort has a worst case running time linear to the total number of characters, same as the other version of radix sort, it is however significantly more wasteful in terms of space; every run could potentially require the construction of (n -1)! arrays of size equal to the alphabet of the text (256 for ASCII), which could also have a devastating efffect on running time brought on by frequent memory accesses. This is mitigated greatly by replacing count sort with insertion sort for small subarrays. 

The code so far does not have an implementation of insertion sort in place, but it does produces the **correct** overall result. Unlike the canonical radix sort implemented here, MSD-radix sort does not require a unique terminating character. It works on any string and on any collection of arbitrary suffixes. Furthermore, recursion can be explicitly made concurrent as sorting subarrays (within a current character postion but **not** subsequent ones) is data independent. 
